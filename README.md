# Monkie Interpreter
Following the book `Writing and interpreter in Go` by Thorsten Ball.

## REPL
To run REPL, run `make repl`

## Lexer
Responsible to create tokens from the source code.

## Parser
The parser takes the tokens generated by the Lexer and creates a syntax tree (parse tree or abstract syntax tree or other hierarchical structure). This gives a structural representation of the input, checking for correct syntax in the process.

The difference between a syntax tree and abstract syntax tree(AST) is the in the AST, some things are omitted depending on the language (like semicolon, comments, braces, bracket and parentheses, etc). These are not represented in the AST, but are rather used to guide the parser.

The core concept of an AST can be the same, but they can differ in the detail based on the language.

Most parser uses context-free grammar (CFG) as input. A CFG is a set of rules that describe how to form correct (valid accound to the syntax) sentences in a language.
The most common notational formats of CFGs are the Backus-Naur Form (BNF) or the Extended Backus-Naur Form (EBNF)

Here, instead of using a existing parser generators (BNF / EBNF), we gonna make our own.

### Types of parsers
- top-down parser: examples:
    - recursive decent parsing
    - early parsing
    - predictive parsing
- bottom-up parser


### The parser we going to use for Monkie lang
We are going to write is a recursive descent parser. This is specifically "top down operator precedence" parser (Pratt parser).
